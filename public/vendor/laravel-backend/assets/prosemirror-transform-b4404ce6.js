import{a as w,R as et,F as g,M as rt,c as nt}from"./prosemirror-model-3f3367be.js";const Q=65535,U=Math.pow(2,16);function it(s,t){return s+t*U}function H(s){return s&Q}function st(s){return(s-(s&Q))/U}const V=1,X=2,A=4,Y=8;class L{constructor(t,e,r){this.pos=t,this.delInfo=e,this.recover=r}get deleted(){return(this.delInfo&Y)>0}get deletedBefore(){return(this.delInfo&(V|A))>0}get deletedAfter(){return(this.delInfo&(X|A))>0}get deletedAcross(){return(this.delInfo&A)>0}}class x{constructor(t,e=!1){if(this.ranges=t,this.inverted=e,!t.length&&x.empty)return x.empty}recover(t){let e=0,r=H(t);if(!this.inverted)for(let n=0;n<r;n++)e+=this.ranges[n*3+2]-this.ranges[n*3+1];return this.ranges[r*3]+e+st(t)}mapResult(t,e=1){return this._map(t,e,!1)}map(t,e=1){return this._map(t,e,!0)}_map(t,e,r){let n=0,i=this.inverted?2:1,o=this.inverted?1:2;for(let l=0;l<this.ranges.length;l+=3){let a=this.ranges[l]-(this.inverted?n:0);if(a>t)break;let h=this.ranges[l+i],p=this.ranges[l+o],f=a+h;if(t<=f){let c=h?t==a?-1:t==f?1:e:e,d=a+n+(c<0?0:p);if(r)return d;let u=t==(e<0?a:f)?null:it(l/3,t-a),m=t==a?X:t==f?V:A;return(e<0?t!=a:t!=f)&&(m|=Y),new L(d,m,u)}n+=p-h}return r?t+n:new L(t+n,0,null)}touches(t,e){let r=0,n=H(e),i=this.inverted?2:1,o=this.inverted?1:2;for(let l=0;l<this.ranges.length;l+=3){let a=this.ranges[l]-(this.inverted?r:0);if(a>t)break;let h=this.ranges[l+i],p=a+h;if(t<=p&&l==n*3)return!0;r+=this.ranges[l+o]-h}return!1}forEach(t){let e=this.inverted?2:1,r=this.inverted?1:2;for(let n=0,i=0;n<this.ranges.length;n+=3){let o=this.ranges[n],l=o-(this.inverted?i:0),a=o+(this.inverted?0:i),h=this.ranges[n+e],p=this.ranges[n+r];t(l,l+h,a,a+p),i+=p-h}}invert(){return new x(this.ranges,!this.inverted)}toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}static offset(t){return t==0?x.empty:new x(t<0?[0,-t,0]:[0,0,t])}}x.empty=new x([]);class z{constructor(t=[],e,r=0,n=t.length){this.maps=t,this.mirror=e,this.from=r,this.to=n}slice(t=0,e=this.maps.length){return new z(this.maps,this.mirror,t,e)}copy(){return new z(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}appendMap(t,e){this.to=this.maps.push(t),e!=null&&this.setMirror(this.maps.length-1,e)}appendMapping(t){for(let e=0,r=this.maps.length;e<t.maps.length;e++){let n=t.getMirror(e);this.appendMap(t.maps[e],n!=null&&n<e?r+n:void 0)}}getMirror(t){if(this.mirror){for(let e=0;e<this.mirror.length;e++)if(this.mirror[e]==t)return this.mirror[e+(e%2?-1:1)]}}setMirror(t,e){this.mirror||(this.mirror=[]),this.mirror.push(t,e)}appendMappingInverted(t){for(let e=t.maps.length-1,r=this.maps.length+t.maps.length;e>=0;e--){let n=t.getMirror(e);this.appendMap(t.maps[e].invert(),n!=null&&n>e?r-n-1:void 0)}}invert(){let t=new z;return t.appendMappingInverted(this),t}map(t,e=1){if(this.mirror)return this._map(t,e,!0);for(let r=this.from;r<this.to;r++)t=this.maps[r].map(t,e);return t}mapResult(t,e=1){return this._map(t,e,!1)}_map(t,e,r){let n=0;for(let i=this.from;i<this.to;i++){let o=this.maps[i],l=o.mapResult(t,e);if(l.recover!=null){let a=this.getMirror(i);if(a!=null&&a>i&&a<this.to){i=a,t=this.maps[a].recover(l.recover);continue}}n|=l.delInfo,t=l.pos}return r?t:new L(t,n,null)}}const B=Object.create(null);class v{getMap(){return x.empty}merge(t){return null}static fromJSON(t,e){if(!e||!e.stepType)throw new RangeError("Invalid input for Step.fromJSON");let r=B[e.stepType];if(!r)throw new RangeError(`No step type ${e.stepType} defined`);return r.fromJSON(t,e)}static jsonID(t,e){if(t in B)throw new RangeError("Duplicate use of step JSON ID "+t);return B[t]=e,e.prototype.jsonID=t,e}}class y{constructor(t,e){this.doc=t,this.failed=e}static ok(t){return new y(t,null)}static fail(t){return new y(null,t)}static fromReplace(t,e,r,n){try{return y.ok(t.replace(e,r,n))}catch(i){if(i instanceof et)return y.fail(i.message);throw i}}}function P(s,t,e){let r=[];for(let n=0;n<s.childCount;n++){let i=s.child(n);i.content.size&&(i=i.copy(P(i.content,t,i))),i.isInline&&(i=t(i,e,n)),r.push(i)}return g.fromArray(r)}class N extends v{constructor(t,e,r){super(),this.from=t,this.to=e,this.mark=r}apply(t){let e=t.slice(this.from,this.to),r=t.resolve(this.from),n=r.node(r.sharedDepth(this.to)),i=new w(P(e.content,(o,l)=>!o.isAtom||!l.type.allowsMarkType(this.mark.type)?o:o.mark(this.mark.addToSet(o.marks)),n),e.openStart,e.openEnd);return y.fromReplace(t,this.from,this.to,i)}invert(){return new M(this.from,this.to,this.mark)}map(t){let e=t.mapResult(this.from,1),r=t.mapResult(this.to,-1);return e.deleted&&r.deleted||e.pos>=r.pos?null:new N(e.pos,r.pos,this.mark)}merge(t){return t instanceof N&&t.mark.eq(this.mark)&&this.from<=t.to&&this.to>=t.from?new N(Math.min(this.from,t.from),Math.max(this.to,t.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}static fromJSON(t,e){if(typeof e.from!="number"||typeof e.to!="number")throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new N(e.from,e.to,t.markFromJSON(e.mark))}}v.jsonID("addMark",N);class M extends v{constructor(t,e,r){super(),this.from=t,this.to=e,this.mark=r}apply(t){let e=t.slice(this.from,this.to),r=new w(P(e.content,n=>n.mark(this.mark.removeFromSet(n.marks)),t),e.openStart,e.openEnd);return y.fromReplace(t,this.from,this.to,r)}invert(){return new N(this.from,this.to,this.mark)}map(t){let e=t.mapResult(this.from,1),r=t.mapResult(this.to,-1);return e.deleted&&r.deleted||e.pos>=r.pos?null:new M(e.pos,r.pos,this.mark)}merge(t){return t instanceof M&&t.mark.eq(this.mark)&&this.from<=t.to&&this.to>=t.from?new M(Math.min(this.from,t.from),Math.max(this.to,t.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}static fromJSON(t,e){if(typeof e.from!="number"||typeof e.to!="number")throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new M(e.from,e.to,t.markFromJSON(e.mark))}}v.jsonID("removeMark",M);class C extends v{constructor(t,e){super(),this.pos=t,this.mark=e}apply(t){let e=t.nodeAt(this.pos);if(!e)return y.fail("No node at mark step's position");let r=e.type.create(e.attrs,null,this.mark.addToSet(e.marks));return y.fromReplace(t,this.pos,this.pos+1,new w(g.from(r),0,e.isLeaf?0:1))}invert(t){let e=t.nodeAt(this.pos);if(e){let r=this.mark.addToSet(e.marks);if(r.length==e.marks.length){for(let n=0;n<e.marks.length;n++)if(!e.marks[n].isInSet(r))return new C(this.pos,e.marks[n]);return new C(this.pos,this.mark)}}return new E(this.pos,this.mark)}map(t){let e=t.mapResult(this.pos,1);return e.deletedAfter?null:new C(e.pos,this.mark)}toJSON(){return{stepType:"addNodeMark",pos:this.pos,mark:this.mark.toJSON()}}static fromJSON(t,e){if(typeof e.pos!="number")throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");return new C(e.pos,t.markFromJSON(e.mark))}}v.jsonID("addNodeMark",C);class E extends v{constructor(t,e){super(),this.pos=t,this.mark=e}apply(t){let e=t.nodeAt(this.pos);if(!e)return y.fail("No node at mark step's position");let r=e.type.create(e.attrs,null,this.mark.removeFromSet(e.marks));return y.fromReplace(t,this.pos,this.pos+1,new w(g.from(r),0,e.isLeaf?0:1))}invert(t){let e=t.nodeAt(this.pos);return!e||!this.mark.isInSet(e.marks)?this:new C(this.pos,this.mark)}map(t){let e=t.mapResult(this.pos,1);return e.deletedAfter?null:new E(e.pos,this.mark)}toJSON(){return{stepType:"removeNodeMark",pos:this.pos,mark:this.mark.toJSON()}}static fromJSON(t,e){if(typeof e.pos!="number")throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");return new E(e.pos,t.markFromJSON(e.mark))}}v.jsonID("removeNodeMark",E);class k extends v{constructor(t,e,r,n=!1){super(),this.from=t,this.to=e,this.slice=r,this.structure=n}apply(t){return this.structure&&q(t,this.from,this.to)?y.fail("Structure replace would overwrite content"):y.fromReplace(t,this.from,this.to,this.slice)}getMap(){return new x([this.from,this.to-this.from,this.slice.size])}invert(t){return new k(this.from,this.from+this.slice.size,t.slice(this.from,this.to))}map(t){let e=t.mapResult(this.from,1),r=t.mapResult(this.to,-1);return e.deletedAcross&&r.deletedAcross?null:new k(e.pos,Math.max(e.pos,r.pos),this.slice)}merge(t){if(!(t instanceof k)||t.structure||this.structure)return null;if(this.from+this.slice.size==t.from&&!this.slice.openEnd&&!t.slice.openStart){let e=this.slice.size+t.slice.size==0?w.empty:new w(this.slice.content.append(t.slice.content),this.slice.openStart,t.slice.openEnd);return new k(this.from,this.to+(t.to-t.from),e,this.structure)}else if(t.to==this.from&&!this.slice.openStart&&!t.slice.openEnd){let e=this.slice.size+t.slice.size==0?w.empty:new w(t.slice.content.append(this.slice.content),t.slice.openStart,this.slice.openEnd);return new k(t.from,this.to,e,this.structure)}else return null}toJSON(){let t={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(t.slice=this.slice.toJSON()),this.structure&&(t.structure=!0),t}static fromJSON(t,e){if(typeof e.from!="number"||typeof e.to!="number")throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new k(e.from,e.to,w.fromJSON(t,e.slice),!!e.structure)}}v.jsonID("replace",k);class I extends v{constructor(t,e,r,n,i,o,l=!1){super(),this.from=t,this.to=e,this.gapFrom=r,this.gapTo=n,this.slice=i,this.insert=o,this.structure=l}apply(t){if(this.structure&&(q(t,this.from,this.gapFrom)||q(t,this.gapTo,this.to)))return y.fail("Structure gap-replace would overwrite content");let e=t.slice(this.gapFrom,this.gapTo);if(e.openStart||e.openEnd)return y.fail("Gap is not a flat range");let r=this.slice.insertAt(this.insert,e.content);return r?y.fromReplace(t,this.from,this.to,r):y.fail("Content does not fit in gap")}getMap(){return new x([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(t){let e=this.gapTo-this.gapFrom;return new I(this.from,this.from+this.slice.size+e,this.from+this.insert,this.from+this.insert+e,t.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(t){let e=t.mapResult(this.from,1),r=t.mapResult(this.to,-1),n=t.map(this.gapFrom,-1),i=t.map(this.gapTo,1);return e.deletedAcross&&r.deletedAcross||n<e.pos||i>r.pos?null:new I(e.pos,r.pos,n,i,this.slice,this.insert,this.structure)}toJSON(){let t={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(t.slice=this.slice.toJSON()),this.structure&&(t.structure=!0),t}static fromJSON(t,e){if(typeof e.from!="number"||typeof e.to!="number"||typeof e.gapFrom!="number"||typeof e.gapTo!="number"||typeof e.insert!="number")throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new I(e.from,e.to,e.gapFrom,e.gapTo,w.fromJSON(t,e.slice),e.insert,!!e.structure)}}v.jsonID("replaceAround",I);function q(s,t,e){let r=s.resolve(t),n=e-t,i=r.depth;for(;n>0&&i>0&&r.indexAfter(i)==r.node(i).childCount;)i--,n--;if(n>0){let o=r.node(i).maybeChild(r.indexAfter(i));for(;n>0;){if(!o||o.isLeaf)return!0;o=o.firstChild,n--}}return!1}function ot(s,t,e,r){let n=[],i=[],o,l;s.doc.nodesBetween(t,e,(a,h,p)=>{if(!a.isInline)return;let f=a.marks;if(!r.isInSet(f)&&p.type.allowsMarkType(r.type)){let c=Math.max(h,t),d=Math.min(h+a.nodeSize,e),u=r.addToSet(f);for(let m=0;m<f.length;m++)f[m].isInSet(u)||(o&&o.to==c&&o.mark.eq(f[m])?o.to=d:n.push(o=new M(c,d,f[m])));l&&l.to==c?l.to=d:i.push(l=new N(c,d,r))}}),n.forEach(a=>s.step(a)),i.forEach(a=>s.step(a))}function lt(s,t,e,r){let n=[],i=0;s.doc.nodesBetween(t,e,(o,l)=>{if(!o.isInline)return;i++;let a=null;if(r instanceof nt){let h=o.marks,p;for(;p=r.isInSet(h);)(a||(a=[])).push(p),h=p.removeFromSet(h)}else r?r.isInSet(o.marks)&&(a=[r]):a=o.marks;if(a&&a.length){let h=Math.min(l+o.nodeSize,e);for(let p=0;p<a.length;p++){let f=a[p],c;for(let d=0;d<n.length;d++){let u=n[d];u.step==i-1&&f.eq(n[d].style)&&(c=u)}c?(c.to=h,c.step=i):n.push({style:f,from:Math.max(l,t),to:h,step:i})}}}),n.forEach(o=>s.step(new M(o.from,o.to,o.style)))}function at(s,t,e,r=e.contentMatch){let n=s.doc.nodeAt(t),i=[],o=t+1;for(let l=0;l<n.childCount;l++){let a=n.child(l),h=o+a.nodeSize,p=r.matchType(a.type);if(!p)i.push(new k(o,h,w.empty));else{r=p;for(let f=0;f<a.marks.length;f++)e.allowsMarkType(a.marks[f].type)||s.step(new M(o,h,a.marks[f]));if(a.isText&&!e.spec.code){let f,c=/\r?\n|\r/g,d;for(;f=c.exec(a.text);)d||(d=new w(g.from(e.schema.text(" ",e.allowedMarks(a.marks))),0,0)),i.push(new k(o+f.index,o+f.index+f[0].length,d))}}o=h}if(!r.validEnd){let l=r.fillBefore(g.empty,!0);s.replace(o,o,new w(l,0,0))}for(let l=i.length-1;l>=0;l--)s.step(i[l])}function ht(s,t,e){return(t==0||s.canReplace(t,s.childCount))&&(e==s.childCount||s.canReplace(0,e))}function Et(s){let e=s.parent.content.cutByIndex(s.startIndex,s.endIndex);for(let r=s.depth;;--r){let n=s.$from.node(r),i=s.$from.index(r),o=s.$to.indexAfter(r);if(r<s.depth&&n.canReplace(i,o,e))return r;if(r==0||n.type.spec.isolating||!ht(n,i,o))break}return null}function pt(s,t,e){let{$from:r,$to:n,depth:i}=t,o=r.before(i+1),l=n.after(i+1),a=o,h=l,p=g.empty,f=0;for(let u=i,m=!1;u>e;u--)m||r.index(u)>0?(m=!0,p=g.from(r.node(u).copy(p)),f++):a--;let c=g.empty,d=0;for(let u=i,m=!1;u>e;u--)m||n.after(u+1)<n.end(u)?(m=!0,c=g.from(n.node(u).copy(c)),d++):h++;s.step(new I(a,h,o,l,new w(p.append(c),f,d),p.size-f,!0))}function Tt(s,t,e=null,r=s){let n=ft(s,t),i=n&&dt(r,t);return i?n.map(K).concat({type:t,attrs:e}).concat(i.map(K)):null}function K(s){return{type:s,attrs:null}}function ft(s,t){let{parent:e,startIndex:r,endIndex:n}=s,i=e.contentMatchAt(r).findWrapping(t);if(!i)return null;let o=i.length?i[0]:t;return e.canReplaceWith(r,n,o)?i:null}function dt(s,t){let{parent:e,startIndex:r,endIndex:n}=s,i=e.child(r),o=t.contentMatch.findWrapping(i.type);if(!o)return null;let a=(o.length?o[o.length-1]:t).contentMatch;for(let h=r;a&&h<n;h++)a=a.matchType(e.child(h).type);return!a||!a.validEnd?null:o}function ct(s,t,e){let r=g.empty;for(let o=e.length-1;o>=0;o--){if(r.size){let l=e[o].type.contentMatch.matchFragment(r);if(!l||!l.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}r=g.from(e[o].type.create(e[o].attrs,r))}let n=t.start,i=t.end;s.step(new I(n,i,n,i,new w(r,0,0),e.length,!0))}function ut(s,t,e,r,n){if(!r.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let i=s.steps.length;s.doc.nodesBetween(t,e,(o,l)=>{if(o.isTextblock&&!o.hasMarkup(r,n)&&mt(s.doc,s.mapping.slice(i).map(l),r)){s.clearIncompatible(s.mapping.slice(i).map(l,1),r);let a=s.mapping.slice(i),h=a.map(l,1),p=a.map(l+o.nodeSize,1);return s.step(new I(h,p,h+1,p-1,new w(g.from(r.create(n,null,o.marks)),0,0),1,!0)),!1}})}function mt(s,t,e){let r=s.resolve(t),n=r.index();return r.parent.canReplaceWith(n,n+1,e)}function wt(s,t,e,r,n){let i=s.doc.nodeAt(t);if(!i)throw new RangeError("No node at given position");e||(e=i.type);let o=e.create(r,null,n||i.marks);if(i.isLeaf)return s.replaceWith(t,t+i.nodeSize,o);if(!e.validContent(i.content))throw new RangeError("Invalid content for node type "+e.name);s.step(new I(t,t+i.nodeSize,t+1,t+i.nodeSize-1,new w(g.from(o),0,0),1,!0))}function Ot(s,t,e=1,r){let n=s.resolve(t),i=n.depth-e,o=r&&r[r.length-1]||n.parent;if(i<0||n.parent.type.spec.isolating||!n.parent.canReplace(n.index(),n.parent.childCount)||!o.type.validContent(n.parent.content.cutByIndex(n.index(),n.parent.childCount)))return!1;for(let h=n.depth-1,p=e-2;h>i;h--,p--){let f=n.node(h),c=n.index(h);if(f.type.spec.isolating)return!1;let d=f.content.cutByIndex(c,f.childCount),u=r&&r[p+1];u&&(d=d.replaceChild(0,u.type.create(u.attrs)));let m=r&&r[p]||f;if(!f.canReplace(c+1,f.childCount)||!m.type.validContent(d))return!1}let l=n.indexAfter(i),a=r&&r[0];return n.node(i).canReplaceWith(l,l,a?a.type:n.node(i+1).type)}function gt(s,t,e=1,r){let n=s.doc.resolve(t),i=g.empty,o=g.empty;for(let l=n.depth,a=n.depth-e,h=e-1;l>a;l--,h--){i=g.from(n.node(l).copy(i));let p=r&&r[h];o=g.from(p?p.type.create(p.attrs,o):n.node(l).copy(o))}s.step(new k(t,t,new w(i.append(o),e,e),!0))}function Ft(s,t){let e=s.resolve(t),r=e.index();return yt(e.nodeBefore,e.nodeAfter)&&e.parent.canReplace(r,r+1)}function yt(s,t){return!!(s&&t&&!s.isLeaf&&s.canAppend(t))}function vt(s,t,e){let r=new k(t-e,t+e,w.empty,!0);s.step(r)}function kt(s,t,e){let r=s.resolve(t);if(r.parent.canReplaceWith(r.index(),r.index(),e))return t;if(r.parentOffset==0)for(let n=r.depth-1;n>=0;n--){let i=r.index(n);if(r.node(n).canReplaceWith(i,i,e))return r.before(n+1);if(i>0)return null}if(r.parentOffset==r.parent.content.size)for(let n=r.depth-1;n>=0;n--){let i=r.indexAfter(n);if(r.node(n).canReplaceWith(i,i,e))return r.after(n+1);if(i<r.node(n).childCount)return null}return null}function zt(s,t,e){let r=s.resolve(t);if(!e.content.size)return t;let n=e.content;for(let i=0;i<e.openStart;i++)n=n.firstChild.content;for(let i=1;i<=(e.openStart==0&&e.size?2:1);i++)for(let o=r.depth;o>=0;o--){let l=o==r.depth?0:r.pos<=(r.start(o+1)+r.end(o+1))/2?-1:1,a=r.index(o)+(l>0?1:0),h=r.node(o),p=!1;if(i==1)p=h.canReplace(a,a,n);else{let f=h.contentMatchAt(a).findWrapping(n.firstChild.type);p=f&&h.canReplaceWith(a,a,f[0])}if(p)return l==0?r.pos:l<0?r.before(o+1):r.after(o+1)}return null}function St(s,t,e=t,r=w.empty){if(t==e&&!r.size)return null;let n=s.resolve(t),i=s.resolve(e);return Z(n,i,r)?new k(t,e,r):new xt(n,i,r).fit()}function Z(s,t,e){return!e.openStart&&!e.openEnd&&s.start()==t.start()&&s.parent.canReplace(s.index(),t.index(),e.content)}class xt{constructor(t,e,r){this.$from=t,this.$to=e,this.unplaced=r,this.frontier=[],this.placed=g.empty;for(let n=0;n<=t.depth;n++){let i=t.node(n);this.frontier.push({type:i.type,match:i.contentMatchAt(t.indexAfter(n))})}for(let n=t.depth;n>0;n--)this.placed=g.from(t.node(n).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){for(;this.unplaced.size;){let h=this.findFittable();h?this.placeNodes(h):this.openMore()||this.dropNode()}let t=this.mustMoveInline(),e=this.placed.size-this.depth-this.$from.depth,r=this.$from,n=this.close(t<0?this.$to:r.doc.resolve(t));if(!n)return null;let i=this.placed,o=r.depth,l=n.depth;for(;o&&l&&i.childCount==1;)i=i.firstChild.content,o--,l--;let a=new w(i,o,l);return t>-1?new I(r.pos,t,this.$to.pos,this.$to.end(),a,e):a.size||r.pos!=this.$to.pos?new k(r.pos,n.pos,a):null}findFittable(){let t=this.unplaced.openStart;for(let e=this.unplaced.content,r=0,n=this.unplaced.openEnd;r<t;r++){let i=e.firstChild;if(e.childCount>1&&(n=0),i.type.spec.isolating&&n<=r){t=r;break}e=i.content}for(let e=1;e<=2;e++)for(let r=e==1?t:this.unplaced.openStart;r>=0;r--){let n,i=null;r?(i=W(this.unplaced.content,r-1).firstChild,n=i.content):n=this.unplaced.content;let o=n.firstChild;for(let l=this.depth;l>=0;l--){let{type:a,match:h}=this.frontier[l],p,f=null;if(e==1&&(o?h.matchType(o.type)||(f=h.fillBefore(g.from(o),!1)):i&&a.compatibleContent(i.type)))return{sliceDepth:r,frontierDepth:l,parent:i,inject:f};if(e==2&&o&&(p=h.findWrapping(o.type)))return{sliceDepth:r,frontierDepth:l,parent:i,wrap:p};if(i&&h.matchType(i.type))break}}}openMore(){let{content:t,openStart:e,openEnd:r}=this.unplaced,n=W(t,e);return!n.childCount||n.firstChild.isLeaf?!1:(this.unplaced=new w(t,e+1,Math.max(r,n.size+e>=t.size-r?e+1:0)),!0)}dropNode(){let{content:t,openStart:e,openEnd:r}=this.unplaced,n=W(t,e);if(n.childCount<=1&&e>0){let i=t.size-e<=e+n.size;this.unplaced=new w(O(t,e-1,1),e-1,i?e-1:r)}else this.unplaced=new w(O(t,e,1),e,r)}placeNodes({sliceDepth:t,frontierDepth:e,parent:r,inject:n,wrap:i}){for(;this.depth>e;)this.closeFrontierNode();if(i)for(let m=0;m<i.length;m++)this.openFrontierNode(i[m]);let o=this.unplaced,l=r?r.content:o.content,a=o.openStart-t,h=0,p=[],{match:f,type:c}=this.frontier[e];if(n){for(let m=0;m<n.childCount;m++)p.push(n.child(m));f=f.matchFragment(n)}let d=l.size+t-(o.content.size-o.openEnd);for(;h<l.childCount;){let m=l.child(h),S=f.matchType(m.type);if(!S)break;h++,(h>1||a==0||m.content.size)&&(f=S,p.push($(m.mark(c.allowedMarks(m.marks)),h==1?a:0,h==l.childCount?d:-1)))}let u=h==l.childCount;u||(d=-1),this.placed=F(this.placed,e,g.from(p)),this.frontier[e].match=f,u&&d<0&&r&&r.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();for(let m=0,S=l;m<d;m++){let b=S.lastChild;this.frontier.push({type:b.type,match:b.contentMatchAt(b.childCount)}),S=b.content}this.unplaced=u?t==0?w.empty:new w(O(o.content,t-1,1),t-1,d<0?o.openEnd:t-1):new w(O(o.content,t,h),o.openStart,o.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let t=this.frontier[this.depth],e;if(!t.type.isTextblock||!D(this.$to,this.$to.depth,t.type,t.match,!1)||this.$to.depth==this.depth&&(e=this.findCloseLevel(this.$to))&&e.depth==this.depth)return-1;let{depth:r}=this.$to,n=this.$to.after(r);for(;r>1&&n==this.$to.end(--r);)++n;return n}findCloseLevel(t){t:for(let e=Math.min(this.depth,t.depth);e>=0;e--){let{match:r,type:n}=this.frontier[e],i=e<t.depth&&t.end(e+1)==t.pos+(t.depth-(e+1)),o=D(t,e,n,r,i);if(o){for(let l=e-1;l>=0;l--){let{match:a,type:h}=this.frontier[l],p=D(t,l,h,a,!0);if(!p||p.childCount)continue t}return{depth:e,fit:o,move:i?t.doc.resolve(t.after(e+1)):t}}}}close(t){let e=this.findCloseLevel(t);if(!e)return null;for(;this.depth>e.depth;)this.closeFrontierNode();e.fit.childCount&&(this.placed=F(this.placed,e.depth,e.fit)),t=e.move;for(let r=e.depth+1;r<=t.depth;r++){let n=t.node(r),i=n.type.contentMatch.fillBefore(n.content,!0,t.index(r));this.openFrontierNode(n.type,n.attrs,i)}return t}openFrontierNode(t,e=null,r){let n=this.frontier[this.depth];n.match=n.match.matchType(t),this.placed=F(this.placed,this.depth,g.from(t.create(e,r))),this.frontier.push({type:t,match:t.contentMatch})}closeFrontierNode(){let e=this.frontier.pop().match.fillBefore(g.empty,!0);e.childCount&&(this.placed=F(this.placed,this.frontier.length,e))}}function O(s,t,e){return t==0?s.cutByIndex(e,s.childCount):s.replaceChild(0,s.firstChild.copy(O(s.firstChild.content,t-1,e)))}function F(s,t,e){return t==0?s.append(e):s.replaceChild(s.childCount-1,s.lastChild.copy(F(s.lastChild.content,t-1,e)))}function W(s,t){for(let e=0;e<t;e++)s=s.firstChild.content;return s}function $(s,t,e){if(t<=0)return s;let r=s.content;return t>1&&(r=r.replaceChild(0,$(r.firstChild,t-1,r.childCount==1?e-1:0))),t>0&&(r=s.type.contentMatch.fillBefore(r).append(r),e<=0&&(r=r.append(s.type.contentMatch.matchFragment(r).fillBefore(g.empty,!0)))),s.copy(r)}function D(s,t,e,r,n){let i=s.node(t),o=n?s.indexAfter(t):s.index(t);if(o==i.childCount&&!e.compatibleContent(i.type))return null;let l=r.fillBefore(i.content,!0,o);return l&&!Mt(e,i.content,o)?l:null}function Mt(s,t,e){for(let r=e;r<t.childCount;r++)if(!s.allowsMarks(t.child(r).marks))return!0;return!1}function It(s){return s.spec.defining||s.spec.definingForContent}function Nt(s,t,e,r){if(!r.size)return s.deleteRange(t,e);let n=s.doc.resolve(t),i=s.doc.resolve(e);if(Z(n,i,r))return s.step(new k(t,e,r));let o=_(n,s.doc.resolve(e));o[o.length-1]==0&&o.pop();let l=-(n.depth+1);o.unshift(l);for(let c=n.depth,d=n.pos-1;c>0;c--,d--){let u=n.node(c).type.spec;if(u.defining||u.definingAsContext||u.isolating)break;o.indexOf(c)>-1?l=c:n.before(c)==d&&o.splice(1,0,-c)}let a=o.indexOf(l),h=[],p=r.openStart;for(let c=r.content,d=0;;d++){let u=c.firstChild;if(h.push(u),d==r.openStart)break;c=u.content}for(let c=p-1;c>=0;c--){let d=h[c],u=It(d.type);if(u&&!d.sameMarkup(n.node(Math.abs(l)-1)))p=c;else if(u||!d.type.isTextblock)break}for(let c=r.openStart;c>=0;c--){let d=(c+p+1)%(r.openStart+1),u=h[d];if(u)for(let m=0;m<o.length;m++){let S=o[(m+a)%o.length],b=!0;S<0&&(b=!1,S=-S);let tt=n.node(S-1),G=n.index(S-1);if(tt.canReplaceWith(G,G,u.type,u.marks))return s.replace(n.before(S),b?i.after(S):e,new w(j(r.content,0,r.openStart,d),d,r.openEnd))}}let f=s.steps.length;for(let c=o.length-1;c>=0&&(s.replace(t,e,r),!(s.steps.length>f));c--){let d=o[c];d<0||(t=n.before(d),e=i.after(d))}}function j(s,t,e,r,n){if(t<e){let i=s.firstChild;s=s.replaceChild(0,i.copy(j(i.content,t+1,e,r,i)))}if(t>r){let i=n.contentMatchAt(0),o=i.fillBefore(s).append(s);s=o.append(i.matchFragment(o).fillBefore(g.empty,!0))}return s}function Ct(s,t,e,r){if(!r.isInline&&t==e&&s.doc.resolve(t).parent.content.size){let n=kt(s.doc,t,r.type);n!=null&&(t=e=n)}s.replaceRange(t,e,new w(g.from(r),0,0))}function bt(s,t,e){let r=s.doc.resolve(t),n=s.doc.resolve(e),i=_(r,n);for(let o=0;o<i.length;o++){let l=i[o],a=o==i.length-1;if(a&&l==0||r.node(l).type.contentMatch.validEnd)return s.delete(r.start(l),n.end(l));if(l>0&&(a||r.node(l-1).canReplace(r.index(l-1),n.indexAfter(l-1))))return s.delete(r.before(l),n.after(l))}for(let o=1;o<=r.depth&&o<=n.depth;o++)if(t-r.start(o)==r.depth-o&&e>r.end(o)&&n.end(o)-e!=n.depth-o)return s.delete(r.before(o),e);s.delete(t,e)}function _(s,t){let e=[],r=Math.min(s.depth,t.depth);for(let n=r;n>=0;n--){let i=s.start(n);if(i<s.pos-(s.depth-n)||t.end(n)>t.pos+(t.depth-n)||s.node(n).type.spec.isolating||t.node(n).type.spec.isolating)break;(i==t.start(n)||n==s.depth&&n==t.depth&&s.parent.inlineContent&&t.parent.inlineContent&&n&&t.start(n-1)==i-1)&&e.push(n)}return e}class R extends v{constructor(t,e,r){super(),this.pos=t,this.attr=e,this.value=r}apply(t){let e=t.nodeAt(this.pos);if(!e)return y.fail("No node at attribute step's position");let r=Object.create(null);for(let i in e.attrs)r[i]=e.attrs[i];r[this.attr]=this.value;let n=e.type.create(r,null,e.marks);return y.fromReplace(t,this.pos,this.pos+1,new w(g.from(n),0,e.isLeaf?0:1))}getMap(){return x.empty}invert(t){return new R(this.pos,this.attr,t.nodeAt(this.pos).attrs[this.attr])}map(t){let e=t.mapResult(this.pos,1);return e.deletedAfter?null:new R(e.pos,this.attr,this.value)}toJSON(){return{stepType:"attr",pos:this.pos,attr:this.attr,value:this.value}}static fromJSON(t,e){if(typeof e.pos!="number"||typeof e.attr!="string")throw new RangeError("Invalid input for AttrStep.fromJSON");return new R(e.pos,e.attr,e.value)}}v.jsonID("attr",R);class J extends v{constructor(t,e){super(),this.attr=t,this.value=e}apply(t){let e=Object.create(null);for(let n in t.attrs)e[n]=t.attrs[n];e[this.attr]=this.value;let r=t.type.create(e,t.content,t.marks);return y.ok(r)}getMap(){return x.empty}invert(t){return new J(this.attr,t.attrs[this.attr])}map(t){return this}toJSON(){return{stepType:"docAttr",attr:this.attr,value:this.value}}static fromJSON(t,e){if(typeof e.attr!="string")throw new RangeError("Invalid input for DocAttrStep.fromJSON");return new J(e.attr,e.value)}}v.jsonID("docAttr",J);let T=class extends Error{};T=function s(t){let e=Error.call(this,t);return e.__proto__=s.prototype,e};T.prototype=Object.create(Error.prototype);T.prototype.constructor=T;T.prototype.name="TransformError";class Jt{constructor(t){this.doc=t,this.steps=[],this.docs=[],this.mapping=new z}get before(){return this.docs.length?this.docs[0]:this.doc}step(t){let e=this.maybeStep(t);if(e.failed)throw new T(e.failed);return this}maybeStep(t){let e=t.apply(this.doc);return e.failed||this.addStep(t,e.doc),e}get docChanged(){return this.steps.length>0}addStep(t,e){this.docs.push(this.doc),this.steps.push(t),this.mapping.appendMap(t.getMap()),this.doc=e}replace(t,e=t,r=w.empty){let n=St(this.doc,t,e,r);return n&&this.step(n),this}replaceWith(t,e,r){return this.replace(t,e,new w(g.from(r),0,0))}delete(t,e){return this.replace(t,e,w.empty)}insert(t,e){return this.replaceWith(t,t,e)}replaceRange(t,e,r){return Nt(this,t,e,r),this}replaceRangeWith(t,e,r){return Ct(this,t,e,r),this}deleteRange(t,e){return bt(this,t,e),this}lift(t,e){return pt(this,t,e),this}join(t,e=1){return vt(this,t,e),this}wrap(t,e){return ct(this,t,e),this}setBlockType(t,e=t,r,n=null){return ut(this,t,e,r,n),this}setNodeMarkup(t,e,r=null,n){return wt(this,t,e,r,n),this}setNodeAttribute(t,e,r){return this.step(new R(t,e,r)),this}setDocAttribute(t,e){return this.step(new J(t,e)),this}addNodeMark(t,e){return this.step(new C(t,e)),this}removeNodeMark(t,e){if(!(e instanceof rt)){let r=this.doc.nodeAt(t);if(!r)throw new RangeError("No node at position "+t);if(e=e.isInSet(r.marks),!e)return this}return this.step(new E(t,e)),this}split(t,e=1,r){return gt(this,t,e,r),this}addMark(t,e,r){return ot(this,t,e,r),this}removeMark(t,e,r){return lt(this,t,e,r),this}clearIncompatible(t,e,r){return at(this,t,e,r),this}}export{z as M,I as R,x as S,Jt as T,Ft as a,k as b,Ot as c,zt as d,Tt as f,Et as l,St as r};
